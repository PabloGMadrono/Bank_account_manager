Description of the Code
First of all, it's important to highlight the fact that I found a way to reduce the number of global variables, which is not recommended when coding in C. To do so, instead of having list_client_ops and account_balance list as global variables, I declared them in the main function and passed them to the respective threads which make use of such variables. Hence, I substituted these two mentioned variables by only declaring the queue as a global variable.

For the sake of clarity in this report, let me divide the analysis of the code into several parts:

1. Transforming the Input File
To do this, I made use of the get function, which reads a whole line from a given input txt. This input file must be opened with fopen, since it is a FILE datatype. The process iterates through the whole file until there are no more lines to be read.

2. Initializing the Threads
The next step was to initialize the ATM and Worker threads. To do so, I used a for loop. And of course, afterwards, with different for loops join such threads. This is necessary to achieve execution in concurrency because otherwise the next thread wouldn’t be created until the previous one has ended.

3. Creating the Queue
Now let me describe how all the processes of the queue work. The queue is basically composed of 5 parameters: the buffer size, which is given as an argument when creating the queue and it is the maximum number of elements that the queue can have; a list of elements, which will contain the actual elements that the queue dequeues; the number of elements, so I can keep track of how full/empty the queue is; the head and the tail, which are integers in charge of storing what is the first element in the queue (the next instruction to be processed) and the last element in the queue (the last instruction queued). And finally, the number of operations, each instruction will have its corresponding number of instructions. The elements themselves are a C structure, composed of a list of characters (a string) for the command and 4 integer parameters for all the possibilities of it. The process of transforming the list of instructions from string to this structure will be explained in the ATM thread section. To enqueue an element, I use the queue_put method, which simply receives the element as an argument, and it is assigned to the tail element. The only problem is that the buffer is circular, hence there is a point where I have to check if the next position of the queue would be the head. Because, if not, it wouldn’t be circular, it would just be an infinite queue. For this, when updating the tail, I make use of the modulus operator, dividing the tail position + 1, obtaining the modulus of such operation divided by the buffer size. The reason for this is that when the tail is less than the buffer size, we will get (tail + 1). But when it is bigger, we will get the first position in the circular buffer. This is easier to see in an example: Let’s say that the tail is in the position 24, with a buffer size of 50. If an element is introduced now, I simply add one to the tail and make the modulus of it divided by 50. The result will, of course, be 25. But let's say that now, the tail is in the position 50. When I add one, I get 51 and when I make the modulus of it divided by 50, I now get 1. With this, I ensure the queue is always within a circle as asked in the statement. To dequeue an element, I simply return the head element in the queue. And of course, move the head to the next element, making use of the just-explained operation to ensure it stays within the circular buffer. Additionally, I created two extra methods to check whether the queue is full and empty, which will be very useful for the threads. And finally, the last method related to the queue is the destroy method. I simply free the memory used to allocate the elements and the queue itself.

4. ATM Thread Handler
As explained in the statement, the ATM is in charge of enqueuing all the instructions. To do so, the ATM thread handler receives as an argument the character array list_client_ops where every element is each line of the input txt file with the instructions to be executed. As explained in the beginning of this report, I did this to use the least number of global variables. As there might be fewer ATMs than instructions to be executed, each thread will loop through a while(1) loop until there are no more instructions to enqueue. To break the loop, I have two global variables to control how many operations have been inputted and printed. The mutex closes in every loop and it will free the loop whenever any of the conditions are met. This is, when the number of client operations is higher than the first line of the input txt, which is the number of instructions that the file contains. In each iteration of the while, the mutex is locked by the ATM, to avoid that two different ATMs enqueue the very same element. The next task in hand now, is to transform these characters into the structure of elements for enqueuing them. I did this through the sscanf() method which allows me to assign each word of the string to a different variable. With this, I easily divide the string into each part of the mentioned structure for instructions. After that I just need to enqueue the element through the explained method in the queue section. But before, I must ensure that there is space in the queue. With that purpose, I use a pthread condition inside a while loop. The while first checks if the queue is full (there is no space for the instruction to be enqueued), if this condition is true, it will enter the wait condition. As seen in class, this will unlock the mutex to allow a worker to get an element and free space in the queue. Once the signal is sent indicating that a space has been free in the queue. The ATM will resume its execution by just enqueuing the element, increasing the number of client operations and sending a conditional signal to the worker thread for the other case (when the worker thread is waiting for an instruction to be enqueued because the queue was empty). And finally, it unlocks the queue. The worker thread works in a similar fashion. In this case, it receives the account balance list as the argument. And it uses a similar while and makes use of the same mutex to lock it every time a worker will dequeue an element. In this case, the worker thread checks first if there are elements in the queue (it is not empty). If the queue is empty, it will wait through the pthread condition the same way as the ATM, although in this case, as explained, it will wait for the ATM to put an element and then the ATM will send the release signal. Then it dequeues an element from the queue through the corresponding method. And proceeds to the parser. There is not much to explain about the parser; it just checks what operation it is and makes the corresponding calculations and changes to the balances. After that the bank number of operations performed is increased, the signal is sent to the worker, and the mutex is unlocked.

5. Free Allocated Memory
Finally, the last step is to free all the allocated memory and to destroy the created queue.
